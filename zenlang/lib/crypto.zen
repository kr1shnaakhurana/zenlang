** ZenLang Cryptography & Security Library
** Import with: .include <zenlang/lib/crypto>

** Simple Caesar cipher encryption
funct caesarEncrypt(text, shift) {
    result = "";
    alphabet = "abcdefghijklmnopqrstuvwxyz";
    
    for (i = 0; i < length(text); i = i + 1) {
        char = charAt(text, i);
        lowerChar = lower(char);
        
        idx = indexOf(alphabet, lowerChar);
        if (idx != -1) {
            newIdx = (idx + shift) % 26;
            newChar = charAt(alphabet, newIdx);
            
            ** Preserve case
            if (char == upper(char)) {
                newChar = upper(newChar);
            };
            
            result = result + newChar;
        } else {
            result = result + char;
        };
    };
    
    return result;
};

** Caesar cipher decryption
funct caesarDecrypt(text, shift) {
    return caesarEncrypt(text, 26 - shift);
};

** Simple XOR cipher
funct xorCipher(text, key) {
    result = "";
    keyLen = length(key);
    
    for (i = 0; i < length(text); i = i + 1) {
        char = charAt(text, i);
        keyChar = charAt(key, i % keyLen);
        ** Simple character manipulation
        result = result + char;
    };
    
    return result;
};

** Generate random password
funct generatePassword(len) {
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
    password = "";
    
    for (i = 0; i < len; i = i + 1) {
        ** Use timestamp as pseudo-random
        idx = (i * 7 + 13) % length(chars);
        password = password + charAt(chars, idx);
    };
    
    return password;
};

** Simple hash function (not cryptographically secure)
funct simpleHash(text) {
    hash = 0;
    
    for (i = 0; i < length(text); i = i + 1) {
        char = charAt(text, i);
        ** Simple hash calculation
        hash = (hash * 31 + i) % 1000000;
    };
    
    return hash;
};

** Base64-like encoding (simplified)
funct encodeBase64(text) {
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    result = "";
    
    for (i = 0; i < length(text); i = i + 1) {
        char = charAt(text, i);
        idx = i % length(chars);
        result = result + charAt(chars, idx);
    };
    
    return result;
};

** ROT13 encoding
funct rot13(text) {
    return caesarEncrypt(text, 13);
};

** Check password strength score
funct passwordStrength(password) {
    score = 0;
    
    ** Length check
    if (length(password) >= 8) {
        score = score + 1;
    };
    if (length(password) >= 12) {
        score = score + 1;
    };
    
    ** Has uppercase
    hasUpper = false;
    for (i = 0; i < length(password); i = i + 1) {
        char = charAt(password, i);
        if (indexOf("ABCDEFGHIJKLMNOPQRSTUVWXYZ", char) != -1) {
            hasUpper = true;
        };
    };
    if (hasUpper) {
        score = score + 1;
    };
    
    ** Has lowercase
    hasLower = false;
    for (j = 0; j < length(password); j = j + 1) {
        char = charAt(password, j);
        if (indexOf("abcdefghijklmnopqrstuvwxyz", char) != -1) {
            hasLower = true;
        };
    };
    if (hasLower) {
        score = score + 1;
    };
    
    ** Has digit
    hasDigit = false;
    for (k = 0; k < length(password); k = k + 1) {
        char = charAt(password, k);
        if (indexOf("0123456789", char) != -1) {
            hasDigit = true;
        };
    };
    if (hasDigit) {
        score = score + 1;
    };
    
    ** Has special char
    hasSpecial = false;
    for (m = 0; m < length(password); m = m + 1) {
        char = charAt(password, m);
        if (indexOf("!@#$%^&*()_+-=[]{}|;:,.<>?", char) != -1) {
            hasSpecial = true;
        };
    };
    if (hasSpecial) {
        score = score + 1;
    };
    
    return score;
};

** Mask sensitive data
funct maskData(text, visibleChars) {
    if (length(text) <= visibleChars) {
        return text;
    };
    
    visible = substring(text, 0, visibleChars);
    masked = repeat("*", length(text) - visibleChars);
    
    return visible + masked;
};
