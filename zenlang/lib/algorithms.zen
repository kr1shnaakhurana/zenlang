** ZenLang Algorithms Library
** Import with: .include <zenlang/lib/algorithms>

** Bubble Sort
funct bubbleSort(arr) {
    n = length(arr);
    sorted = [];
    
    ** Copy array
    for (i = 0; i < n; i = i + 1) {
        push(sorted, arr[i]);
    };
    
    ** Sort
    for (i = 0; i < n - 1; i = i + 1) {
        for (j = 0; j < n - i - 1; j = j + 1) {
            if (sorted[j] > sorted[j + 1]) {
                ** Swap
                temp = sorted[j];
                sorted[j] = sorted[j + 1];
                sorted[j + 1] = temp;
            };
        };
    };
    
    return sorted;
};

** Binary Search
funct binarySearch(arr, target) {
    left = 0;
    right = length(arr) - 1;
    
    while (left <= right) {
        mid = int((left + right) / 2);
        
        if (arr[mid] == target) {
            return mid;
        };
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        };
    };
    
    return -1;
};

** Linear Search
funct linearSearch(arr, target) {
    for (i = 0; i < length(arr); i = i + 1) {
        if (arr[i] == target) {
            return i;
        };
    };
    return -1;
};

** Find maximum in array
funct findMax(arr) {
    if (length(arr) == 0) {
        return null;
    };
    
    maxVal = arr[0];
    for (i = 1; i < length(arr); i = i + 1) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        };
    };
    
    return maxVal;
};

** Find minimum in array
funct findMin(arr) {
    if (length(arr) == 0) {
        return null;
    };
    
    minVal = arr[0];
    for (i = 1; i < length(arr); i = i + 1) {
        if (arr[i] < minVal) {
            minVal = arr[i];
        };
    };
    
    return minVal;
};

** Selection Sort
funct selectionSort(arr) {
    n = length(arr);
    sorted = [];
    
    ** Copy array
    for (i = 0; i < n; i = i + 1) {
        push(sorted, arr[i]);
    };
    
    ** Sort
    for (i = 0; i < n - 1; i = i + 1) {
        minIdx = i;
        
        for (j = i + 1; j < n; j = j + 1) {
            if (sorted[j] < sorted[minIdx]) {
                minIdx = j;
            };
        };
        
        ** Swap
        if (minIdx != i) {
            temp = sorted[i];
            sorted[i] = sorted[minIdx];
            sorted[minIdx] = temp;
        };
    };
    
    return sorted;
};

** Insertion Sort
funct insertionSort(arr) {
    n = length(arr);
    sorted = [];
    
    ** Copy array
    for (i = 0; i < n; i = i + 1) {
        push(sorted, arr[i]);
    };
    
    ** Sort
    for (i = 1; i < n; i = i + 1) {
        key = sorted[i];
        j = i - 1;
        
        while (j >= 0 && sorted[j] > key) {
            sorted[j + 1] = sorted[j];
            j = j - 1;
        };
        
        sorted[j + 1] = key;
    };
    
    return sorted;
};

** Reverse array
funct reverseArray(arr) {
    result = [];
    for (i = length(arr) - 1; i >= 0; i = i - 1) {
        push(result, arr[i]);
    };
    return result;
};

** Rotate array left
funct rotateLeft(arr, positions) {
    n = length(arr);
    if (n == 0) {
        return arr;
    };
    
    positions = positions % n;
    result = [];
    
    for (i = positions; i < n; i = i + 1) {
        push(result, arr[i]);
    };
    
    for (j = 0; j < positions; j = j + 1) {
        push(result, arr[j]);
    };
    
    return result;
};

** Rotate array right
funct rotateRight(arr, positions) {
    n = length(arr);
    if (n == 0) {
        return arr;
    };
    
    return rotateLeft(arr, n - (positions % n));
};

** Check if array is sorted
funct isSorted(arr) {
    for (i = 0; i < length(arr) - 1; i = i + 1) {
        if (arr[i] > arr[i + 1]) {
            return false;
        };
    };
    return true;
};

** Find pairs that sum to target
funct findPairSum(arr, target) {
    pairs = [];
    
    for (i = 0; i < length(arr); i = i + 1) {
        for (j = i + 1; j < length(arr); j = j + 1) {
            if (arr[i] + arr[j] == target) {
                push(pairs, [arr[i], arr[j]]);
            };
        };
    };
    
    return pairs;
};

** Count inversions in array
funct countInversions(arr) {
    count = 0;
    n = length(arr);
    
    for (i = 0; i < n - 1; i = i + 1) {
        for (j = i + 1; j < n; j = j + 1) {
            if (arr[i] > arr[j]) {
                count = count + 1;
            };
        };
    };
    
    return count;
};

** Find missing number in sequence
funct findMissing(arr, n) {
    expectedSum = (n * (n + 1)) / 2;
    actualSum = 0;
    
    for (i = 0; i < length(arr); i = i + 1) {
        actualSum = actualSum + arr[i];
    };
    
    return expectedSum - actualSum;
};

** Kadane's algorithm - maximum subarray sum
funct maxSubarraySum(arr) {
    if (length(arr) == 0) {
        return 0;
    };
    
    maxSoFar = arr[0];
    maxEndingHere = arr[0];
    
    for (i = 1; i < length(arr); i = i + 1) {
        maxEndingHere = max([arr[i], maxEndingHere + arr[i]]);
        maxSoFar = max([maxSoFar, maxEndingHere]);
    };
    
    return maxSoFar;
};
