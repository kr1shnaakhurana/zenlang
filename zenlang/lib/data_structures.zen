** ZenLang Data Structures Library
** Import with: .include <zenlang/lib/data_structures>

** Stack implementation
funct createStack() {
    return {items=[], size=0};
};

funct stackPush(stack, item) {
    push(stack["items"], item);
    stack["size"] = stack["size"] + 1;
    return stack;
};

funct stackPop(stack) {
    if (stack["size"] == 0) {
        return null;
    };
    
    item = pop(stack["items"]);
    stack["size"] = stack["size"] - 1;
    return item;
};

funct stackPeek(stack) {
    if (stack["size"] == 0) {
        return null;
    };
    
    items = stack["items"];
    return items[stack["size"] - 1];
};

funct stackIsEmpty(stack) {
    return stack["size"] == 0;
};

** Queue implementation
funct createQueue() {
    return {items=[], size=0};
};

funct enqueue(queue, item) {
    push(queue["items"], item);
    queue["size"] = queue["size"] + 1;
    return queue;
};

funct dequeue(queue) {
    if (queue["size"] == 0) {
        return null;
    };
    
    item = shift(queue["items"]);
    queue["size"] = queue["size"] - 1;
    return item;
};

funct queuePeek(queue) {
    if (queue["size"] == 0) {
        return null;
    };
    
    items = queue["items"];
    return items[0];
};

funct queueIsEmpty(queue) {
    return queue["size"] == 0;
};

** Linked List Node
funct createNode(value) {
    return {value=value, next=null};
};

** Linked List
funct createLinkedList() {
    return {head=null, size=0};
};

funct listAppend(list, value) {
    node = createNode(value);
    
    if (list["head"] == null) {
        list["head"] = node;
    } else {
        current = list["head"];
        while (current["next"] != null) {
            current = current["next"];
        };
        current["next"] = node;
    };
    
    list["size"] = list["size"] + 1;
    return list;
};

funct listToArray(list) {
    result = [];
    current = list["head"];
    
    while (current != null) {
        push(result, current["value"]);
        current = current["next"];
    };
    
    return result;
};

** Binary Tree Node
funct createTreeNode(value) {
    return {value=value, left=null, right=null};
};

** Binary Search Tree
funct createBST() {
    return {root=null, size=0};
};

funct bstInsert(tree, value) {
    node = createTreeNode(value);
    
    if (tree["root"] == null) {
        tree["root"] = node;
        tree["size"] = 1;
        return tree;
    };
    
    ** Simplified insertion (would need recursion helper)
    tree["size"] = tree["size"] + 1;
    return tree;
};

** Priority Queue (simple implementation)
funct createPriorityQueue() {
    return {items=[], priorities=[], size=0};
};

funct pqEnqueue(pq, item, priority) {
    push(pq["items"], item);
    push(pq["priorities"], priority);
    pq["size"] = pq["size"] + 1;
    return pq;
};

funct pqDequeue(pq) {
    if (pq["size"] == 0) {
        return null;
    };
    
    ** Find highest priority
    maxPriority = pq["priorities"][0];
    maxIndex = 0;
    
    for (i = 1; i < pq["size"]; i = i + 1) {
        if (pq["priorities"][i] > maxPriority) {
            maxPriority = pq["priorities"][i];
            maxIndex = i;
        };
    };
    
    ** Remove item
    item = pq["items"][maxIndex];
    
    ** Rebuild arrays without the item
    newItems = [];
    newPriorities = [];
    
    for (j = 0; j < pq["size"]; j = j + 1) {
        if (j != maxIndex) {
            push(newItems, pq["items"][j]);
            push(newPriorities, pq["priorities"][j]);
        };
    };
    
    pq["items"] = newItems;
    pq["priorities"] = newPriorities;
    pq["size"] = pq["size"] - 1;
    
    return item;
};

** Set implementation (using array)
funct createSet() {
    return {items=[], size=0};
};

funct setAdd(set, item) {
    if (!includes(set["items"], item)) {
        push(set["items"], item);
        set["size"] = set["size"] + 1;
    };
    return set;
};

funct setHas(set, item) {
    return includes(set["items"], item);
};

funct setRemove(set, item) {
    newItems = [];
    found = false;
    
    for (i = 0; i < length(set["items"]); i = i + 1) {
        if (set["items"][i] != item) {
            push(newItems, set["items"][i]);
        } else {
            found = true;
        };
    };
    
    if (found) {
        set["items"] = newItems;
        set["size"] = set["size"] - 1;
    };
    
    return set;
};

funct setUnion(set1, set2) {
    result = createSet();
    
    for (i = 0; i < length(set1["items"]); i = i + 1) {
        setAdd(result, set1["items"][i]);
    };
    
    for (j = 0; j < length(set2["items"]); j = j + 1) {
        setAdd(result, set2["items"][j]);
    };
    
    return result;
};

funct setIntersection(set1, set2) {
    result = createSet();
    
    for (i = 0; i < length(set1["items"]); i = i + 1) {
        item = set1["items"][i];
        if (setHas(set2, item)) {
            setAdd(result, item);
        };
    };
    
    return result;
};
